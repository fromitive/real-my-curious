# 무결성 제약조건, 키, 관계대수, 뷰, 인덱스

## 무결성 제약조건
데이터 무결성: 데이터의 일관성과 정확성을 유지하고 보장하는 것
DB가 무결성을 유지하려면 튜플의 **삽입, 삭제, 수정**이 일어날 때 데이터의 제약조건 준수 여부를 확인해야 함
- Python3 에서 정렬된 배열에 정렬을 유지한 채로 원소를 추가하는 `insort() 느낌`


무결성 제약조건에는 튜플에 삽입 가능한 데이터의 값을 제한하는 도메인 무결성 제약조건과 관계 데이터 모델의 핵심적인 관계 표현을 위한 개체 무결성 제약 조건, 참조 무결성 제약 조건이 있다.

### 개체 무결성 제약조건
> PK는 `not null && unique`
### 참조 무결성 제약조건
> FK는 `null` 이거나 참조하는 릴레이션의 PK값과 동일해야 함
- 다시 말해, 릴레이션은 참조할 수 없는 외래 키를 가질 수 없음
### 도메인 무결성 제약조건
> 튜플에 삽입 가능한 데이터의 값을 제한
- `not null`, `varchar(255)`, ...

### 무결성 제약조건 수행
각 릴레이션은 데이터의 변경이 일어날 때 마다 제약조건에 위배될 수 있으므로, 제약조건의 준수 여부는 변경 시 마다 확인해야 함

특히 FK로 연관관계를 맺은 두 릴레이션이 있고, 부모가 삭제될 때가 고려할 것이 많은데, 일반적으로 다음과 같이 4가지의 모드를 지원함
`ON DELETE ~`
- CASCADE: 부모가 삭제될 경우 참조하고 있는 자식들도 모두 함께 삭제
- DEFAULT: 부모를 삭제하고 자식의 FK를 미리 지정한 기본값으로 변경
- SET NULL: 부모를 삭제하고 자식의 FK를 `null`로 설정
- RESTRICTED: 참조하고 있는 자식 릴레이션이 있다면 삭제 거부

---
## 키
> 릴레이션에서 특정 튜플을 식별할 때 사용하는 속성 또는 속성의 집합

따라서 키가 되는 속성(들)은 반드시 고유한 값을 가져야 한다.

### 슈퍼키
> 튜플을 유일하게 식별할 수 있는 하나의 속성 혹은 속성의 집합
- **튜플을 유일하게 식별할 수 있는 값이면 모두 슈퍼키가 될 수 있음**

### 후보키
> 튜플을 유일하게 식별할 수 있는 속성의 **최소 집합**

### 기본키 (PK)
> 여러 후보키 중 선택된 하나의 키
- `not null && unique`
- 키 값의 변동 X
- 되도록 적은 수의 칼럼으로 구성되는 것이 좋음

### 대체키 (Alternative)
> 기본키로 선정되지 않은 후보키
- 후보키 - 기본키 = 대체키

### 대리키 (Surrogate) (vs 자연키)
> 식별자가 너무 길거나, 여러 개의 속성으로 구성된 경우 인위적으로 추가하는 식별자. 인공키라고도 한다.
- 비즈니스 모델의 밖에서 오로지 키 역할을 하기 위해 인조적으로 만든 속성. ex) UUID, 자동증가 ID
- 반면 자연키는 비즈니스 모델에서 자연스럽게 나오는 속성. ex) 주민번호

보통 PK로 대리키를 두고, 자연키는 UK로 사용

### 외래키 (FK)
> 다른 릴레이션의 기본키를 참조하는 속성. 타 릴레이션의 PK를 참조하여 릴레이션 간의 관계를 표현함
- PK와 달리 `nullable`, 중복 가능

---
## 관계 대수
관계 데이터 모델의 정형적인 언어는 크게 관계 해석식과 관계 대수로 나뉨
관계 해석식이 **원하는 데이터만을 명시**하는 선언적인 언어인 반면,
관계 대수는 **'어떻게 질의를 수행할 것인가?'를 명시**하는 절차적 언어임

### 연산
- 셀렉션 Selection (σ) : 특정 조건을 만족하는 튜플 선택
- 프로젝션 Projection (π) : 특정 속성(칼럼)만을 선택, 나머지는 버림
- 합집합 Union (∪) : 두 릴레이션을 합함
- 교집합 Intersection (∩) : 두 릴레이션의 공통되는 부분을 구함
- 차집합 (ㅡ) : 좌항의 릴레이션에만 존재하는 튜플만을 선택
- 데카르트 곱 (×) : 두 릴레이션의 튜플들을 짝지을 수 있는 모든 순서쌍을 포함한 릴레이션 구함

-  조인 (⋈) : 두 릴레이션의 공통 속성 중 속성 값이 같은 튜플을 수평 결합
	- 데카르트 곱과 셀렉션 연산을 합한 것과 결과가 동일
-  디비전 (÷) : 우항의 릴레이션의 모든 값을 포함하는 좌항의 튜플을 추출

![image.jpg](https://github.com/user-attachments/assets/d9b5d327-3fbe-4125-b8be-ca606c870fb4)

## 뷰
> 테이블(들)에서 선택적으로 특정 열이나 행을 가진 가상의 테이블 또는 쿼리 결과

실제 데이터를 저장하지는 않으며, DB에 저장된 테이블의 구조와 데이터에 대한 쿼리를 단순화하고 추상화하기 위해 사용

### 장점
- 쿼리 간소화
	- 뷰를 통해 복잡한 쿼리나 조인을 간소화하고, 필요한 데이터에 쉽게 접근할 수 있음
- 보안 및 권한 관리
	- 특정 사용자에게 필요한 데이터만 노출 가능
	- → 권한 부여 단순화 용이

### 단점
- 정의 변경 불가!!
- 인덱스 구성 불가
- 뷰(v1)를 포함하는 뷰(v2)가 정의되었을 때, v1이 삭제되면 v2 역시 cascade로 삭제됨

---
## 인덱스
> 추가적인 쓰기 작업과 저장 공간을 활용하여 테이블의 검색 속도를 향상시키기 위한 자료구조

- 데이터에 변경사항(삽입/삭제/수정)이 일어날 때 인덱스 역시 재구성되어야 함
	- → 무분별한 인덱스의 사용은 오히려 성능 저하의 원인이 될 수 있음!
- B-Tree / B+ Tree 가 주로 사용됨
	- 해시를 사용하는 방법도 있는데, 단건 조회 시 성능은 좋으나 부등호 연산 등의 범위 검색을 지원할 수 없음

### 특징
- 테이블에서 한 개 이상의 속성을 이용하여 생성
- 정렬된 속성과 데이터의 위치만 보유하므로 테이블보다 저장공간을 덜 차지함
- 저장된 값들은 테이블의 부분집합이 됨

### 인덱스를 사용하면 좋은 경우
- 규모가 작지 않은 테이블
- `INSERT`, `UPDATE`, `DELETE가` 자주 발생하지 않는 컬럼
- `JOIN이나` `WHERE` 또는 `ORDER BY`에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼

### 기본 인덱스
PK를 기반으로 만드는 인덱스. DBMS에 의해 자동으로 생성됨
키가 순서로 된 인덱스를 가지고 직접 접근한 후, 키 값에 따라 정렬된 순차 데이터 파일을 접근하는 방식
- 즉, 직접 접근 후 순차 접근이 일어남
<img width="645" alt="image" src="https://github.com/user-attachments/assets/644b2ef3-4318-4198-9a06-c95d8a50cdaf">

### 보조 인덱스
기본 인덱스 이외의 인덱스. PK가 아닌 필드에 대해 명시적으로 추가한 인덱스

### 클러스터링 인덱스
> 탐색 키 값에 따라 정렬된 데이터 파일을 갖는 인덱스

<img width="708" alt="image" src="https://github.com/user-attachments/assets/5eb880f3-5a98-444b-b91a-34637249d33d">
인덱스의 엔트리들도 정렬되어 있으며, 인덱스의 정렬 순서와 데이터 파일의 정렬 순서가 일치하므로 범위 질의에 유용함
기본 인덱스는 클러스터링 인덱스의 한 종류

### 비 클러스터링 인덱스
데이터 파일의 레코드들이 탐색 키 값과 무관하게 저장되어 있어 인덱스 엔트리들이 인접해 있더라도 레코드들이 인접함을 보장할 수 없는 인덱스
<img width="671" alt="image" src="https://github.com/user-attachments/assets/4c79b907-e8f6-4496-a69a-f019671a01cf">
- 보조 인덱스는 비 클러스터링 인덱스 형태로 구성됨

### 다단계 인덱스
인덱스 자체가 큰 경우 인덱스 엔트리의 탐색 시간을 줄이기 위해 단일 단계 인덱스에 대해 다시 인덱스를 정의할 수 있음
- 리눅스의 EXT4 파일 시스템 구조, Multilevel Paging 같은 느낌
대부분의 다단계 인덱스는 B Tree나 B+ Tree를 사용함
