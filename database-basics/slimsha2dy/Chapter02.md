## 무결성 제약조건

**무결성**: 데이터베이스에서 데이터에 결함이 없는 상태, 즉 데이터의 정확성과 일관성을 유지하는 것

**무결성 제약조건**: 데이터베이스의 무경성을 보장하기 위해 설정되는 조건. 데이터의 저장, 삭제, 수정 등을 제한하거나 조절하는 역할
→ 데이터베이스의 상태를 일관되게 유지하고 무결성을 보장하는 주요 목적을 갖고 있다

1. 개체 무결성: 각 릴레이션의 기본키를 구성하는 속성은 널 값이나 중복된 값을 가질 수 없음
    - 기본키는 항상 유일하고 비어 있을 수 없는 값이어야 함
    - 예) 학번이 기본키라면 항상 값이 존재해야 하고 겹치면 안됨
2. 참조 무결성: 외래키 값은 널 값이거나 참조하는 릴레이션의 기본키 값과 동일해야 함
    - 즉, 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없음
    - 예) 수강 릴레이션의 학번 속성에는 학생 릴레이션에 존재하지 않는 학번 값을 입력할 수 없다
3. 도메인 무결성: 각 속성들의 값은 도메인에 속한 값이어야 함
    - 예) 나이 속성에 음수 값이나 이상한 값이 들어갈 수 없음
4. 고유 무결성: 특정 column에 대해 고유한 값을 갖도록 조건이 주어진 경우, 각 튜플이 가지는  column 값들은 중복될 수 없음
    - 에) unique한 값인 학번에는 중복된 값이 들어갈 수 없음
5. NULL 무결성: 릴레이션의 특정 속성 값은 NULL이 될 수 없음
    - 예) 주민등록번호가 반드시 입력되어야 한다면 NULL 값은 허용되지 않음
6. 키 무결성: 각 릴레이션은 최소한 한 개 이상의 키를 가져야 하며 키는 튜플을 식별할 수 있는 값이어야 함
    - 예) 학생 릴레이션에서 학생 속성은 학생의 유일한 식별자로 사용된다

---

## 키

데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 다른 튜플들과 구별할 수 있는 유일한 기준이 되는 속성(attribute)

- **superkey**: relation에서 tuples를 유니크하게 식별할 수 있는 attributes set
    - e.g. Player(id, name, team_id, back_number, birth_date)의 superkey
        - {id, name, team_id, back_number, birth_date}
        - {id, name}: 같은 id와 이름을 가진 선수는 없다
        - {name, team_id, back_number}: 같은 팀 안에 같은 등번호는 없다
- **candidate** **key(후보키)**: 어느 한 attribute라도 제거하면 유니크하게 tuples를 식별할 수 없는 super key
    - key or minimal superkey
    - e.g. 위의 예시에서 {id}, {team_id, back_number}: 나눴을 때 독립적으로 유니크하게 식별할 수 없다
- **primary key:** relation에서 tuples를 unique하게 식별하기 위해 선택된 candidate key
    - 보통 attribute 수가 적은 걸 선택하게 됨
- **unique key**: primary key가 아닌 candidate keys
    - alternate key
- **foreign key**: 다른 relation의 PK를 참조하는 attribute set
    - e.g. PLAYER, TEAM(id, name, manage)
        - 여기서 PLAYER의 {team_id}
        - team_id는 TEAM의 id를 참조

---

## 관계대수

관계 대수식: 기존 릴레이션들로부터 새로운 릴레이션을 생성하는 절차적 언어 문법, 기본적인 연산자들을 적용하여 보다 복잡한 관계 대수식을 점차적으로 만들 수 있다.
즉, 수에 연산자를 적용해 결과를 얻어내는 것처럼, 릴레이션에 관계대수라는 연산자들을 적용해서 원하는 릴레이션을 도출할 수 있는 것이다.

사용자가 원하는 데이터를 얻기 위한 절차를 시스템에 명세하는 데이터 언어. DBMS들에서 널리 사용되는 SQL의 이론적인 기초. 또한 SQL을 구현하고 최적화하기 위해 DBMS의 내부 언어로서도 사용됨.

### 8대 연산자

1. 셀렉션: 테이블에서 한 개 끄집어 낸다.
    - Employee 테이블에서 DNO가 3인 행을 도출
2. 프로젝션: 학생 테이블에서 특정한 학번 이름만 출력.
    - Employee 테이블에서 직급 열을 도출
3. 합집합
    - 중복을 제거한 합을 도출
4. 교집합
    - 겹치는 부분만을 도출
5. 차집합: A - B
6. 카티션 곱: 나올 수 있는 조합 경우의 수
    - 결과가 크면 오버헤드가 커지므로 실제로는 카티션 곱 연산자는 사용하지 않고 조인 연산자를 사용함
7. 조인: 결합
    - 세타 조인: 두 릴레이션에서 공통된 attribute를 기준으로 비교 연산자를 사용하여 조건을 만족하는 튜플들을 결합하는 것
    - 동등 조인: 세타 조인 중 비교 연산자가 =인 조인
    - 자연 조인: 동등 조인의 결과 릴레이션에서 조인 attribute를 제외한 조인(중복 필드 제거)
    - 외부 조인: 일반적인 조인은 두 릴레이션에서 대응되는 튜플이 없을 경우 그 튜플을 결과에 포함시키지 않지만 외부 조인은 포함시키고 null로 채운다
        - 어느 릴레이션을 기준으로 null을 채우는지에 따라 left/right/full outer join으로 나뉜다
8. 디비전: 분할
    - 한 테이블에서 다른 테이블의 모든 값을 가지고 있는 행들을 찾아주는 연산자

---

- 집단 함수
    - 한 릴레이션에서 특정 속성들의 값들에 대해 총합, 평균, 최대, 최소, 개수 등의 연산을 수행하는 함수
    - 관계 대수의 표현력을 높이기 위해 새로 추가된 연산자
    - 각 그룹에 대해 독립적으로 적용되며 그룹화 연산자가 함께 사용됨
    - AVG, SUM, MIN, MAX, COUNT
- 그룹화
    - 한 릴레이션에서 특정 속성들의 값에 따라 튜플들을 여러 그룹으로 분류하고 각 그룹에 대해 집단 함수를 적용하는 연산자
    - DNO의 값이 같은 것끼리 그룹화하여 각 그룹에 대한 평균값을 구함
- 관계 대수와 SQL
    - 관계 대수는 RDB에서 릴레이션을 조작하기 위한 절차적 언어
        - 즉 원하는 데이터를 얻기 위해 어떤 연산을 어떤 순서로 수행할 것인지 수학 공식처럼 명시함으로써 릴레이션을 도출할 수 있음
    - SQL은 RDB에서 데이터를 정의하고 조작하기 위한 선언적 언어
        - 원하는 데이터가 무엇인지만 선언하면 데이터베이스 시스템이 알아서 질의를 수행함
    - 애초에 관계 대수의 업그레이드 버전이 SQL임
    - SQL은 관계 대수의 한계를 극복하고, RDB에서 다양한 데이터를 쉽고 강력하게 조작할 수 있게 해줌
- 관계 해석
    - 원하는 데이터가 무엇인지만 선언하는 비절차적 언어
    
    ```sql
    -- EMPLOYEE 릴레이션에서 급여가 3000 이상인 사원들의 이름과 급여를 찾는 관계 해석 식
    {<t.Ename, t.Salary> | t ∈ EMPLOYEE ∧ t.Salary ≥ 3000}
    
    -- 위의 관계 해석식과 매칭되는 SQL 코드
    SELECT Ename, Salary
    FROM EMPLOYEE
    WHERE Salary >= 3000;
    ```
    
    - 알아야 함?
        - 관계 해석은 비절차적 언어이므로 컴퓨터가 직접 실행할 수 있는 형태가 아님
        → 관계 해석으로 표현된 질의를 관계 대수로 변환하거나 SQL로 번역해야 컴퓨터로 실행할 수 있음
        - 즉 실제 데이터베이스 시스템에서 구현하기 어려움
        - 하지만 데이터베이스의 이론적 배경과 논리적 구조를 이해할 수 있음

---

## 뷰

**뷰 테이블**: 데이터베이스에서 테이블의 일부 또는 특정 조건에 따라 필터링된 데이터만을 포함하는 가상 테이블.

- 실제로 데이터를 저장하지 않고 기존 테이블 데이터를 기반으로 쿼리를 실행하여 필요한 정보를 반환
- 이를 통해 데이터의 일부분에 집중하거나 복잡한 쿼리를 간소화할 수 있음
- 데이터의 보안, 효율성, 유지보수 측면에서 유용하게 사용될 수 있음
- 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른  뷰도 자동으로 삭제됨
- 장점
    - 유연성: 다양한 데이터를 기반으로 필요한 정보를 동적으로 생성
    - 효율성: 기존 테이블에서 필요한 정보에 빠르게 접근할 수 있음
    - 보안: 기존 테이블에 대한 접근 권한을 제한할 수 있어 보안 강화 가능
    - 간결성: 복잡한 쿼리를 단순화해 중복된 코드를 줄여서 유지보수에 용이
    - 가독성: 데이터 모델을 더 읽기 쉽게
    - 재사용성: 다른 쿼리나 뷰에서 재사용 가능
    - 표준화: 데이터 모델의 일관성과 표준화를 유지할 수 있도록 도와줌
    - 성능 최적화: 복잡한 연산을 최적화해 접근과 처리 속도 향상
    - 유지보수성: 데이터 모델이 변경되더라도 기존 뷰만 업데이트할 수 있음
    - 통합성: 여러 테이블에서 필요한 정보를 통합해서 관리할 수 있음
- 단점
    - 성능 저하: 동적으로 생성되므로 쿼리 실행 시 추가적인 계산이 필요
    - 데이터 일관성: 기존 데이터를 참조하므로 구조나 데이터 변경 시 뷰를 추가적으로 업데이트해주어야 함
    - 제약 조건: 기존 테이블의 제약 조건을 상속하지 않으므로 별도로 정의해야 함
    - 독립적인 인덱스를 가질 수 없음
    - 정의를 변경할 수 없음 → 삭제 후 재생성해야 함

```sql
// 생성
CREATE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;

// 수정
CREATE OR REPLACE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;

// 이름 변경
ALTER VIEW customer_master RENAME TO customer_info;

// 삭제
DROP VIEW [ IF EXISTS ] view_name;

// 조회
SELECT *
FROM information_schema.views
WHERE table_schema = 'public';
```

---

## 인덱스

WHERE에서 인덱스가 안 걸려 있다면 full scan을 하므로 탐색 시간은 O(N)

하지만 인덱스가 걸려 있다면 O(logN) (B-tree based index에서)

- 왜 씀?
    - 조건을 만족하는 튜플들을 빠르게 조회하기 위해
    - 빠르게 정렬(order by)하거나 그룹핑(group by)하기 위해 
    - 특정 조건(WHERE, ON)을 만족하는 데이터들을 빠르게 찾기 위해서
- mysql 기준 인덱스 만드는 법
    - SELECT * FROM player WHERE name = ‘Sonny’;
        - 이름은 중복이 가능한 attribute임
        - CREATE INDEX 인덱스이름 ON 테이블이름 (attribute)
    - SELECT * FROM player WHERE team_id = 105 and backnumber = 7;
        - 같은 팀 안에서는 등번호가 유니크하므로 선수들을 유니크하게 식별할 수 있음
        - 두 attribute를 합쳐서 인덱스를 만들어야 함, 근데 유니크하게 식별할 수 있으므로
        - CREATE UNIQUE INDEX 인덱스이름 ON 테이블이름 (attribute1, attribute2);
    - UNIQUE는 사용하면 뭔 차이임? 고유해야 함을 나타내기 위해?
        - 실제 성능 상 차이는 미미하거나 없다
        - 무결성을 위한 조건의 의미가 큼
    - 이미 사용되고 있는 테이블에 사용하는 명령문인데 바로 생성하면서 걸어줄 수도 있음
        
        ```sql
        CREATE TABLE player (
        	id INT PRIMARY KEY,
        	name VARCHAR(20) NOT NULL,
        	...
        	INDEX player_name_idx (name),
        	UNIQUE INDEX team_id_backnumber_idx (team_id, backnumber)
        );
        ```
        
    - 두 개 이상의 attribute로 구성된 인덱스를 “multicolumn index, composite index”라고 함
    - 내림차순 인덱스, DESCENDING
        - 큰 값들이 중요하고 자주 찾을 때 내림차순 옵션을 적용할 수 있음
        - CREATE INDEX player_name ON player (name desc);
    - 산술식 바탕의 인덱스, Function Based
        - 이 산술식을 따르는 새로운 컬럼을 만들고 그에 대한 인덱스를 만드는 것이 더 좋을 수 있음
        - CREATE INDEX player_name ON player (컬럼이 포함된 산술식);
    - 비트맵을 사용한 인덱스, BITMAP
        - 각 구분에 대해 비트맵을 사용하여 인덱스를 생성함
        - discrete(이산형), binomial, 카테고리형, 범주형 변수인 컬럼의 경우 적합할 수 있음(카디널리티 값이 낮은 경우 == 특정 데이터 집합의 유니크한 값의 개수가 높은 경우 == 중복도가 높은 경우)
        - 예) 성별, 부서번호, 국가, T/F, 등급 등
        - CREATE BITMAP INDEX player_name ON player (name)
- primary key에는 인덱스가 자동 생성된다
    - unique 제약 조건을 정의하면 인덱스가 자동으로 생성됨 → 고유 인덱스
    사용자가 직접 생성한 인덱스를 비고유 인덱스
    - foreign key의 경우, mysql은 자동으로 인덱스를 생성해 주지만 다른 RDBMS의 경우 자동 생성되지 않을 수 있음(join할 때 성능 차이가 나니까 유의)
- 테이블의 인덱스를 조회하려면?
    - SHOW INDEX FROM player

---

### B-Tree 기반 인덱스의 작동 방식

INDEX에는 걸려있는 값들이 정렬된 형태로 저장되어 있고, 해당 값에는 실제 테이블에 저장된 포인터(주소)가 저장되어 있음

INDEX(a)에 WHERE a = 9; 를 검색하면 이분 탐색으로 a가 9인 값을 전부 찾음

WHERE a = 7 AND b = 95; 를 검색하면 이분탐색으로 a가 7인 값을 찾고, 그 해당 주소에 찾아가서 b가 일치하는지 확인함. 그리고 a가 7인 부분을 또 찾아서 비교해야 하는데 이분탐색이므로 양쪽 방향을 전부 확인해야 함. 그렇게 a가 7인 부분을 전부 확인하면서 조건에 일치하는 행을 전부 직접 주소로 찾아가서 확인.
→ 즉, 하나의 조건에만 인덱스가 걸려있으면 매번 실제 주소를 찾아가서 다시 확인을 해봐야 함 == a가 7인 행을 full scan해야 하는 것

이를 해결하기 위해선 a와 b를 묶은 인덱스를 만들어야 한다.

두 개로 묶으면 먼저 넣은 attribute 기준으로 먼저 정렬이 됨: CREATE INDEX(a, b)를 할 경우 a로 먼저 정렬 → 그렇기 때문에 인덱스의 attribute 순서가 중요할 것

근데 또 여기서 WHERE b = 95; 를 사용해야 한다? 이전에 a, b로 묶어놓은 인덱스가 쓸모가 없어짐. 따라서 b에 대한 인덱스가 추가적으로 필요할 것.

→ a, b로 묶은 인덱스는 a로 검색, a와 b로 검색은 되지만 b로 검색은 안 됨

사용되는 쿼리에 맞춰서 적절하게 인덱스를 걸어줘야 쿼리가 빠르게 처리될 수 있다.

### 왜 B-Tree를 인덱스로 사용할까?
AVL이나 Red-Black Tree도 시간복잡도는 같다 근데 왜 얘네는 안씀?

그 이유는 Disk I/O 때문. 디스크에서 한 번 읽어오는 단위인 block은 트리의 노드 크기와 같다.

즉 접근해야 하는 리프 노드까지 가는 깊이만큼 Disk I/O가 발생할 것.

즉, 노드에 분기가 많아서 깊이가 좀 더 적은 B-Tree를 사용하는 것이다.
(차후 내용 추가)

---

- 근데 나는 SELECT 문만 적어줬는데 어떻게 인덱스를 잘 선택하지?
→ DBMS에 있는 optimizer가 알아서 적절하게 인덱스를 선택
- 근데 가끔 옵티마이저가 이상한 선택을 해서 쿼리 성능이 안 나올 수 있다. 따라서 특정 인덱스를 사용하도록 명시하고 싶으면?
    - SELECT * FROM player USE INDEX (backnumber_idx) WHERE backnumber = 7;
    → 권장 느낌임. 웬만하면 이 인덱스 써주세요~
    - SELECT * FROM player FORCE INDEX (backnumber_idx) WHERE backnumber = 7;
    → 무조건 써라. 근데 옵티마이저가 판단했을 때 저 인덱스로 원하는 데이터가 불가능하면 full scan을 하고 아니면 무조건 사용
    - IGNORE INDEX를 통해 특정 인덱스를 제외할 수도 있음
    - 근데 이거 쓸 일 있나? 결국엔 신인 옵티마이저 형님이 판단하는데
        - 가끔 데이터 히스토그램이 업데이트되지 않아 옵티마이저가 잘못 판단할 수도 있다 함
- 인덱스는 막 만들어도 괜찮을까?
    - 각 인덱스는 별도의 데이터들이 존재하게 됨
    - table에 write(INSERT, DELETE, UPDATE)할 때마다 모든 index도 변경 발생 → 오버헤드
        - INSERT 시 B-트리의 구조 조정 시간도
        - DELETE 시 인덱스에 존재하는 값은 삭제하지 않고 사용 안한다는 표시로 남게 됨 → 작업이 반복되면 불필요한 공간들이 많아지고 인덱스의 효율이 떨어지게 된다
    - 추가적인 저장 공간을 차지하게 됨
    - 즉 불필요한 인덱스를 만들지 말자
- **Covering index**
    - team_id와 backnumber로 인덱스가 걸려있을 때, SELECT team_id, backnumber FROM player WHERE team_id = 5;를 실행할 경우 인덱스에 얻고자 하는 모든 정보가 있으므로 실제 테이블에 갈 필요가 없음
    - 조회하려는 attributes를 인덱스가 모두 커버할 때 조회 성능이 더 빠름
    - 의도적으로 두 attribute를 묶어서 이렇게 조회 성능을 올릴 수 있는 기술이 있다(a랑 b로 검색 조건을 걸지 않는 상황에서도)
- **Hash index**
    - hash table을 사용해 인덱스 구현
    - 조회가 O(1) → B-Tree 인덱스보다 좋은 거 아님?
    - rehashing에 대한 부담(해시 테이블 꽉 차서 사이즈 늘릴 때)
    - equality(=, ≠) 비교만 가능, range(<, >) 비교 불가능
    - 실제로 mysql의 경우 이 인덱스도 제공해서 선택할 수 있긴 함
    - multicolumn index의 경우 전체 attributes에 대한 조회만 가능
        - (a, b)로 걸면 a로 검색이 불가하다
    - 그래서 보통은 B-tree 기반 인덱스를 사용함
- Full scan이 더 좋은 경우
    - 테이블에 데이터가 조금 있을 때
    - 조회하려는 데이터가 테이블의 상당 부분을 차지할 때(카디널리티가 낮을 때)
        - SK를 사용하는 고객들을 조회하고 싶은데 SK가 대부분인 경우
    - 인덱스는 테이블에 항상 접근해야 하므로
    - 이는 옵티마이저가 판단함
    - 보통 20~25% 정도의 스캔이 필요하면 full scan이 더 좋다고 함
- **카디널리티(Cardinality)**: 특정 데이터 집합의 유니크한 값의 개수
    - 중복도가 낮으면 카디널리티가 높다
    - 주민등록번호는 값이 중복되지 않지만 이름은 중복되기도 한다
    → 주민등록번호의 카디널리티가 더 높다
    - DISTINCT 사용 전후의 차이가 적을수록(중복도가 낮을수록) 카디널리티가 높아진다
    - NDV(Number of Distinct Value): 특정 컬럼에 Unique한 값의 개수
    == 카디널리티
    - 선택도(Selectivity): 데이터 집합에서 특정 값을 얼마나 잘 골라낼 수 있는지
        - 전체 레코드 중에서 조건절에 의해 선택될 것으로 예상되는 레코드의 비율
        - 카디널리티 / 총 레코드 수 * 100
        - 선택도가 낮은 컬럼에 인덱스를 걸면 인덱스 효율이 높아진다
        - 선택도가 10%라면 이 컬럼을 기준으로 WHERE 절을 사용했을 때 약 10%의 레코드가 조회된다는 뜻
    - 카디널리티가 높고 선택도가 낮을수록(5~10% 적합) 인덱스를 사용했을 때 높은 효율을 보여준다
- 이미 데이터가 몇 백만 건 이상 있는 테이블에 인덱스를 생성하는 경우 시간이 몇 분 이상 소요될 수 있고 이 때문에 성능에 안 좋은 영향을 줄 수 있음
    - 그러므로 트래픽이 적을 때 생성하는게 좋다~
